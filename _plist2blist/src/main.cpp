#include <pch.h>

int main() {
	SetConsoleOutputCP(CP_UTF8);
	auto&& cp = std::filesystem::current_path();
	std::cout << "tool: *.plist -> *.blist ( key can't contains space or dot ) + res_tp_frames.h & cpp\nworking dir: " << cp.string() << "\npress any key continue...";
	std::cin.get();

	std::unordered_map<std::string, std::vector<std::string>> plists;		// plist file name : keys
	std::map<std::string, std::string> keys;								// key : owner plist file name
	std::unordered_map<std::string, xx::TexturePackerReader::Plist> tps;	// plist file name : data

	int n = 0;
	for (auto&& entry : std::filesystem::/*recursive_*/directory_iterator(cp)) {
		if (!entry.is_regular_file()) continue;
		auto&& p = entry.path();
		if (p.extension() != u8".plist") continue;

		auto plistName = xx::U8AsString(p.filename().u8string());
		auto fullpath = xx::U8AsString(std::filesystem::absolute(p).u8string());
		auto blistPath = fullpath.substr(0, fullpath.size() - 6) + ".blist";

		auto [iter, success] = plists.emplace(plistName, std::vector<std::string>{});
		assert(success);

		xx::Data fd;
		if (int r = xx::ReadAllBytes(p, fd)) {
			std::cerr << "ReadAllBytes failed. r = " << r << " fn = " << p << std::endl;
			return -__LINE__;
		}

		auto&& rtv = tps.emplace(plistName, xx::TexturePackerReader::Plist{});
		assert(rtv.second);
		auto& tp = rtv.first->second;
		if (int r = tp.Load(fd)) {
			std::cerr << "tp.Load failed. r = " << r << " fn = " << p << std::endl;
			return -__LINE__;
		}

		std::cout << "\nhandle file: " << p << std::endl;
		xx::Data d;
		d.WriteBuf("blist_1 ");	// custom file head 8 bytes
		d.Write(tp.metadata.realTextureFileName);
		d.Write(tp.metadata.premultiplyAlpha);
		d.Write(tp.frames.size());
		for (auto& f : tp.frames) {
			std::cout << "handle frame: " << f.name << std::endl;

			for (auto const& c : f.name) {
				if (c == '.' || c == ' ') {
					std::cerr << "**************************** bad key name( can't contain ' ' or '.' ): " << f.name
						<< "\n**************************** in plist: " << plistName
						<< std::endl;
					return -__LINE__;
				}
			}

			if (auto [iter, success] = keys.emplace(f.name, plistName); !success) {
				std::cerr << "**************************** duplicate res name: " << f.name
					<< "\n**************************** in plist: " << iter->second
					<< "\n**************************** and plist " << plistName
					<< std::endl;
				return -__LINE__;
			}
			iter->second.push_back(f.name);


			d.Write(f.name);
			d.Write(f.aliases);
			if (f.anchor.has_value()) {
				d.WriteFixed((uint8_t)1);
				d.Write(f.anchor->x, f.anchor->y);
			} else {
				d.WriteFixed((uint8_t)0);
			}
			d.WriteFixed(f.spriteOffset.x);
			d.WriteFixed(f.spriteOffset.y);
			d.WriteFixed(f.spriteSize.width);
			d.WriteFixed(f.spriteSize.height);
			d.WriteFixed(f.spriteSourceSize.width);
			d.WriteFixed(f.spriteSourceSize.height);
			d.WriteFixed(f.textureRect.x);
			d.WriteFixed(f.textureRect.y);
			d.WriteFixed(f.textureRect.width);
			d.WriteFixed(f.textureRect.height);
			d.WriteFixed(f.textureRotated);
		}
		xx::WriteAllBytes((std::u8string&)blistPath, d);
		++n;
	}

	// group by prefix...._number
	std::map<std::string_view, std::vector<std::string_view>> keyGroups;

	for (auto& [k, _] : keys) {
		std::string_view sv(k);
		if (auto idx = sv.find_last_of('_'); idx != sv.npos) {
			auto k = sv.substr(0, idx);
			auto v = sv.substr(idx + 1);
			if (v.find_first_not_of("0123456789"sv) != v.npos) continue;
			keyGroups[k].push_back(v);
		}
	}

	// sort by number
	for (auto&& kv : keyGroups) {
		auto& ss = kv.second;
		std::sort(ss.begin(), ss.end(), [](std::string_view const& a, std::string_view const& b)->bool {
			return xx::SvToNumber<int>(a) < xx::SvToNumber<int>(b);
		});
	}


	std::string h;

	xx::Append(h, R"#(#pragma once
#include "pch.h"

// this file is generated by tool: plist2blist

struct ResTpFrames {
	xx::Task<> AsyncLoad(std::string picRoot);
)#");

	for (auto& [key, plistfn] : keys) {
		auto& tp = tps[plistfn];
		auto f = &tp.frames[0];
		for (auto& o : tp.frames) {
			if (o.name == key) {
				f = &o;
				break;
			}
		}

		xx::XY anchor{ 0.5, 0.5 };
		if (f->anchor.has_value()) {
			anchor = *f->anchor;
		}
		
		xx::AppendFormat(h, R"#(
	xx::Ref<xx::Frame> {0};
	xx::Ref<xx::GLTexture> _tex_{0};
	GLuint _texid_{0}{{};	// unsafe
	static constexpr xx::XY _size_{0}{{ {1}, {2} };
	static constexpr xx::XY _anchor_{0}{{ {3}, {4} };
	static constexpr xx::UVRect _uvrect_{0}{{ {5}, {6}, {7}, {8} };
)#"
			, key, f->spriteSize.width, f->spriteSize.height
			, anchor.x, anchor.y
			, f->textureRect.x, f->textureRect.y, f->textureRect.width, f->textureRect.height
		);
	}

	if (!keyGroups.empty()) {
		xx::Append(h, R"#(
)#");
	}

	for (auto&& kv : keyGroups) {
		xx::AppendFormat(h, R"(
	xx::Listi32<xx::Ref<xx::Frame>> {0}_;
	static constexpr int32_t _countof_{0}_{{ {1} };)", kv.first, kv.second.size());
	}

	xx::Append(h, R"#(
};
)#");

	std::string c;


	xx::Append(c, R"#(#include "pch.h"
#include "res_tp_frames.h"

// this file is generated by tool: plist2blist

xx::Task<> ResTpFrames::AsyncLoad(std::string picRoot) {)#");

	for (auto& plist : plists) {
		xx::AppendFormat(c, R"#(
	{{
		auto& eg = xx::EngineBase3::Instance();
#ifdef __EMSCRIPTEN__
		auto tp = co_await eg.AsyncLoadTexturePackerFromUrl(picRoot + "{0}");
#else
		auto tp = eg.LoadTexturePacker<true>(picRoot + "{0}");
#endif
		xx_assert(tp);
		auto map = tp->GetMapSV();
)#", plist.first.substr(0, plist.first.size() - 5) + "blist");

		for (auto& key : plist.second) {
			xx::AppendFormat(c, R"#(
		this->{0} = map["{0}"sv];
		this->_tex_{0} = this->{0}->tex;
		this->_texid_{0} = this->_tex_{0}->GetValue();)#", key);
		}
		xx::AppendFormat(c, R"#(
	}
)#");
	}

	if (!keyGroups.empty()) {
		xx::Append(c, R"#(
	// fill groups
)#");
		for (auto&& kv : keyGroups) {
			for (auto&& s : kv.second) {
				xx::AppendFormat(c, R"(
	{0}_.Add({0}_{1});)", kv.first, s);
			}
		}
	}

	xx::Append(c, R"#(
	co_return;
}
)#");


	// save to file
	if (int r = xx::WriteAllBytes(u8"res_tp_frames.h", h.data(), h.size())) {
		std::cerr << "write file res_tp_frames.h failed! r = " << r << std::endl;
		return -__LINE__;
	}
	if (int r = xx::WriteAllBytes(u8"res_tp_frames.cpp", c.data(), c.size())) {
		std::cerr << "write file res_tp_frames.h failed! r = " << r << std::endl;
		return -__LINE__;
	}

	xx::CoutN("finished! generated res_tp_frames.h & cpp! press any key continue...");
	std::cin.get();

	return 0;
}
